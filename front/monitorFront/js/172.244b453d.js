"use strict";(self["webpackChunkfront"]=self["webpackChunkfront"]||[]).push([[172],{1172:function(e,t,n){n.r(t),n.d(t,{default:function(){return b}});var r=n(3396);const o={class:"container",ref:"container"};function i(e,t,n,i,a,s){return(0,r.wg)(),(0,r.iD)("div",o,null,512)}var a=n(4870),s=n(7327),l=(n(1439),n(7585),n(5315),n(7658),n(4161));class _{constructor(e){(0,s.Z)(this,"_gl",null),(0,s.Z)(this,"_imageMap",new Map),(0,s.Z)(this,"_textureMap",new Map),(0,s.Z)(this,"_samplerMap",new Map),(0,s.Z)(this,"_shaderScriptMap",new Map),(0,s.Z)(this,"_updateProgram",null),(0,s.Z)(this,"_trajectoryProgram",null),(0,s.Z)(this,"_simulationVAO",null),(0,s.Z)(this,"_simulationVAO2",null),(0,s.Z)(this,"_renderVAO",null),(0,s.Z)(this,"_renderVAO2",null),(0,s.Z)(this,"_XFBO",null),(0,s.Z)(this,"_XFBO2",null),(0,s.Z)(this,"_simulationBuffer",null),(0,s.Z)(this,"_xfSimulationBuffer",null),(0,s.Z)(this,"_UBO",null),(0,s.Z)(this,"_sVAO",null),(0,s.Z)(this,"_rVAO",null),(0,s.Z)(this,"_xfBO",null),(0,s.Z)(this,"_unPackBuffer",null),(0,s.Z)(this,"_uboMapBuffer",new Float32Array(12)),(0,s.Z)(this,"_textureOffsetArray",[]),(0,s.Z)(this,"_beginBlock",-1),(0,s.Z)(this,"count",0),(0,s.Z)(this,"flag",!0),(0,s.Z)(this,"imagePre",0),(0,s.Z)(this,"imageNext",1),this.option=e,this._segmentPrepare=e.constraints.maxSegmentNum,this._shaderScriptMap.set(d.UPDATE_VERTEX,"#version 300 es\n    precision highp float;\n\n    layout (location=0) in vec3 particleInfo;\n    layout (location=1) in float age;\n\n    layout (std140) uniform FlowFieldUniforms\n    {\n        float progress;\n        float segmentNum;\n        float fullLife;\n        float dropRate;\n        float dropRateBump;\n        float speedFactor;\n        vec4 flowBoundary; // vec4(uMin, vMin, uMax, vMax)\n        \n    };\n\n    uniform sampler2D flowField[2];\n    uniform sampler2D mask[2];\n    // uniform sampler2D validAddress;\n    uniform float randomSeed;\n\n    out vec3 newInfo;\n    out float aliveTime;\n\n    // pseudo-random generator\n    float rand(const vec2 co) {\n        const vec3 rand_constants = vec3(12.9898, 78.233, 4375.85453);\n        float t = dot(rand_constants.xy, co);\n        return abs(fract(sin(t) * (rand_constants.z + t)));\n    }\n\n    float drop(float velocity, vec2 uv)\n    {\n        vec2 seed = (particleInfo.xy + uv) * randomSeed;\n        float drop_rate = dropRate + velocity * dropRateBump;\n        return step(drop_rate, rand(seed));\n    }\n\n    float is_in_flow_progress(vec2 resolution, vec2 uv)\n    {\n        ivec2 texcoords = ivec2(uv * resolution);\n        vec4 color1 = texelFetch(mask[0], texcoords, 0);\n        vec4 color2 = texelFetch(mask[1], texcoords, 0);\n\n        ivec2 xy1 = ivec2((int(color1.r * 255.0) << 8) + int(color1.g * 255.0), (int(color1.b * 255.0) << 8) + int(color1.a * 255.0));\n        ivec2 xy2 = ivec2((int(color2.r * 255.0) << 8) + int(color2.g * 255.0), (int(color2.b * 255.0) << 8) + int(color2.a * 255.0));\n        float isInFlow1 = float((xy1 == texcoords));\n        float isInFlow2 = float((xy2 == texcoords));\n\n        return step(0.0, 2.0 * mix(isInFlow1, isInFlow2, progress) - 1.0);\n    }\n\n    vec2 get_speed(sampler2D sFlowField, vec2 uv)\n    {\n        vec2 speed_tl = texture(sFlowField, uv).rg;\n        return speed_tl;\n    }\n\n    vec2 lookup_speed(vec2 uv, vec2 resolution)\n    {\n        vec2 lSpeed = get_speed(flowField[0], uv);\n        vec2 nSpeed = get_speed(flowField[1], uv);\n        vec2 speed = mix(lSpeed, nSpeed, progress);\n        return mix(flowBoundary.xy, flowBoundary.zw, speed);\n    }\n\n    float speed_rate(vec2 speed)\n    {\n        return length(speed) / length(flowBoundary.zw);\n    }\n\n    void die(vec2 resolution)\n    {\n        vec2 seed = randomSeed + particleInfo.xy;\n\n        vec2 uv = vec2(rand(seed + 1.3), rand(seed + 2.1));\n        vec4 rebirthColor = texture(mask[1], uv);\n        float rebirth_x = float((int(rebirthColor.r * 255.0) << 8) + int(rebirthColor.g * 255.0));\n        float rebirth_y = float((int(rebirthColor.b * 255.0) << 8) + int(rebirthColor.a * 255.0));\n        rebirth_x = rebirth_x + rand(seed + rebirth_x);\n        rebirth_y = rebirth_y + rand(seed + rebirth_y);\n\n        vec2 rebirthPos = vec2(rebirth_x, rebirth_y) / resolution;\n        newInfo = vec3(rebirthPos, speed_rate(lookup_speed(rebirthPos, resolution)));\n        aliveTime = age + 1.0;\n    }\n\n    void simulation(vec2 resolution)\n    {\n        vec2 uv = particleInfo.xy;\n        vec2 speed = lookup_speed(uv, resolution);\n        float speedRate = speed_rate(speed);\n\n        vec2 nPos = vec2(particleInfo.xy + speed * speedFactor / resolution);\n        nPos = clamp(nPos, vec2(0.0), vec2(1.0));\n        float dropped = drop(speedRate, uv) * is_in_flow_progress(resolution, nPos);\n\n        newInfo = mix(particleInfo, vec3(nPos, speedRate), dropped);\n        aliveTime = mix(fullLife - segmentNum, age + 1.0, dropped);\n    }\n\n    void freeze()\n    {\n        newInfo = particleInfo;\n        aliveTime = age + 1.0;\n    }\n\n    void rebirth()\n    {\n        newInfo = particleInfo;\n        aliveTime = 0.0;\n    }\n\n    void main()\n    {\n        vec2 resolution = vec2(textureSize(mask[1], 0));\n        \n        if (age < fullLife - segmentNum)\n        {\n            simulation(resolution);\n        }\n        else if (age == fullLife)\n        {\n            die(resolution);\n        }\n        else if (abs(fullLife - age) <= segmentNum)\n        {\n            freeze();\n        }\n        else\n        {\n            rebirth();\n        }\n    }\n    "),this._shaderScriptMap.set(d.UPDATE_FRAGMENT,"#version 300 es\n    precision highp float;\n\n    void main() \n    {\n    }\n    "),this._shaderScriptMap.set(d.TRAJECTORY_VERTEX,"#version 300 es\n    precision highp float;\n\n    layout (location = 0) in float isAlive;\n\n    layout (std140) uniform FlowFieldUniforms\n    {\n        float progress;\n        float segmentNum;\n        float fullLife;\n        float dropRate;\n        float dropRateBump;\n        float speedFactor;\n        float colorScheme;\n        vec4 flowBoundary;\n    };\n\n    uniform sampler2D particlePool;\n    uniform sampler2D projectionTexture;\n    uniform int blockNum;\n    uniform int beginBlock;\n    uniform int blockSize;\n    uniform float fillWidth;\n    uniform float aaWidth;\n    uniform vec2 viewport;\n    uniform mat4 u_matrix;\n\n    out struct Stream_line_setting \n    {\n        float edgeParam;\n        float alphaDegree;\n        float velocity; // a percentage\n        float isDiscarded;\n    } sls;\n\n\n    vec4 ReCoordinate(vec2 pos) {\n\n        vec3 geoPos;\n        geoPos = texture(projectionTexture, pos).xyz;\n        vec4 res = u_matrix * vec4(geoPos, 1.0);\n        return res;\n    }\n\n    ivec2 get_uv(int vertexIndex)\n    {\n        // calculate the blockIndex of the current vertx\n        int blockIndex = (beginBlock - vertexIndex + blockNum) % blockNum;\n\n        // calculate original uv of the block\n        int textureWidth = textureSize(particlePool, 0).x;\n        int columnNum = textureWidth / blockSize;\n        ivec2 blockUV = ivec2(blockIndex % columnNum, blockIndex / columnNum) * blockSize;\n\n        // calculate uv of the current vertex\n        ivec2 vertexUV = blockUV + ivec2(gl_InstanceID % blockSize, gl_InstanceID / blockSize);\n\n        return vertexUV;\n    }\n\n    vec4 transfer_to_clip_space(vec2 pos)\n    {\n        return ReCoordinate(pos);\n    }\n\n    vec4 get_clip_position(ivec2 uv)\n    {\n        return transfer_to_clip_space(texelFetch(particlePool, uv, 0).rg);\n    }\n\n    vec2 get_vector(vec2 beginVertex, vec2 endVertex)\n    {\n        return normalize(endVertex - beginVertex);\n    }\n\n    void main()\n    {\n        // get screen positions from particle pool\n        float parity = float(gl_VertexID % 2);\n        int currentVertex = gl_VertexID / 2;\n        int nextVertex = currentVertex + 1;\n        ivec2 c_uv = get_uv(currentVertex);\n        ivec2 n_uv = get_uv(nextVertex);\n        vec4 cv_pos_CS = get_clip_position(c_uv);\n        vec4 nv_pos_CS = get_clip_position(n_uv);\n        vec2 cv_pos_SS = cv_pos_CS.xy / cv_pos_CS.w;\n        vec2 nv_pos_SS = nv_pos_CS.xy / nv_pos_CS.w;\n\n        // calculate the screen offset\n        float speedRate = texelFetch(particlePool, c_uv, 0).b;\n        float lineWidth = (fillWidth + aaWidth * 2.0);// * mix(2.0, 1.0, clamp(pow(speedRate * 10.0, 3.0), 0.0, 1.0));\n        vec2 cn_vector = get_vector(cv_pos_SS, nv_pos_SS);\n        float screenOffset = lineWidth / 2.0;\n\n        // translate current vertex position\n        vec3 view = vec3(0.0, 0.0, 1.0);\n        vec2 v_offset = normalize(cross(view, vec3(cn_vector, 0.0))).xy * mix(1.0, -1.0, parity);  //等价于以下\n        // vec2 v_offset = normalize(vec2(-cn_vector.y, cn_vector.x)).xy * mix(1.0, -1.0, parity);\n        \n        vec2 vertexPos_SS = cv_pos_SS + v_offset * screenOffset / viewport;\n\n        //////////////\n        // calculate vertex position in screen coordinates\n        vec2 vertexPos_CS = vertexPos_SS * cv_pos_CS.w;\n        gl_Position = vec4(vertexPos_CS, 0.0, cv_pos_CS.w);\n\n        // prepare for anti-aliasing\n        sls.edgeParam = 2.0 * parity - 1.0;\n\n        float segmentRate = float(currentVertex) / segmentNum;\n        sls.alphaDegree = 1.0 - segmentRate;\n\n        sls.velocity = speedRate;\n        sls.isDiscarded = isAlive;\n    }\n    "),this._shaderScriptMap.set(d.TRAJECTORY_FRAGMENT,"#version 300 es\n    precision highp float;\n\n    in struct Stream_line_setting \n    {\n        float edgeParam;\n        float alphaDegree;\n        float velocity; // a percentage\n        float isDiscarded;\n    } sls;\n\n    layout (std140) uniform FlowFieldUniforms\n    {\n        float progress;\n        float segmentNum;\n        float fullLife;\n        float dropRate;\n        float dropRateBump;\n        float speedFactor;\n        float colorScheme;\n        vec4 flowBoundary;\n    };\n    uniform float fillWidth;\n    uniform float aaWidth;\n\n    out vec4 fragColor;\n\n    int rampColors0[8] = int[](\n        0x3288bd,\n        0x66c2a5,\n        0xabdda4,\n        0xe6f598,\n        0xfee08b,\n        0xfdae61,\n        0xf46d43,\n        0xd53e4f\n    );\n\n    int rampColors1[8] = int[](\n        0x8c510a,\n        0xbf812d,\n        0xdfc27d,\n        0xf6e8c3,\n        0xc7eae5,\n        0x80cdc1,\n        0x35978f,\n        0x01665e\n    );\n    int rampColors2[8] = int[](\n        0x8dd3c7,\n        0xffffb3,\n        0xbebada,\n        0xfb8072,\n        0x80b1d3,\n        0xfdb462,\n        0xb3de69,\n        0xfccde5\n    );\n\n    int[8] rampColors()\n    {\n        if (colorScheme == 0.0)\n            return rampColors0;\n        if (colorScheme == 1.0)\n            return rampColors1;\n        if (colorScheme == 2.0)\n            return rampColors2;\n    } \n\n    vec3 colorFromInt(int color)\n    {\n        float b = float(color & 0xFF) / 255.0;\n        float g = float((color >> 8) & 0xFF) / 255.0;\n        float r = float((color >> 16) & 0xFF) / 255.0;\n\n        return vec3(r, g, b);\n    }\n\n    vec3 velocityColor(float speed)\n    {\n        float bottomIndex = floor(speed * 10.0);\n        float topIndex = mix(bottomIndex + 1.0, 7.0, step(6.0, bottomIndex));\n        float interval = mix(1.0, 4.0, step(6.0, bottomIndex));\n\n        vec3 slowColor = colorFromInt(rampColors()[int(bottomIndex)]);\n        vec3 fastColor = colorFromInt(rampColors()[int(topIndex)]);\n\n        return mix(slowColor, fastColor, (speed * 10.0 - float(bottomIndex)) / interval);\n    }\n\n    float getAlpha(float param)\n    {\n        if (aaWidth == 0.0) return 1.0;\n        float alpha = 1.0 - sin(clamp((param * (0.5 * fillWidth + aaWidth) - 0.5 * fillWidth) / aaWidth, 0.0, 1.0) * 2.0 / 3.141592653);\n        return alpha;\n    }\n\n    void main() \n    {\n        if (sls.isDiscarded >= fullLife) discard; \n        float alpha = getAlpha(abs(sls.edgeParam));\n\n        // vec3 color = mix(colorFromInt(rampColors[int(sls.velocity * 7.0)]), colorFromInt(rampColors[int(sls.velocity * 7.0 + 0.5)]), fract(sls.velocity * 7.0));\n        vec3 color = velocityColor(sls.velocity);\n        // color = mix(vec3(0.7), color, alpha);\n        // fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n        fragColor = vec4(color, 1.0) * alpha * sls.alphaDegree;\n        // fragColor = vec4(1.0) * alpha;\n    }\n    ")}async prepareAsyncImage(){const e=[];for(let t=0;t<2;t++)e.push(this.getImage(d.FLOW_FIELD_IMAGE+t,this.option.flowFields[t],"flipY")),e.push(this.getImage(d.SEEDING_IMAGE+t,this.option.seeding[t],"flipY"));e.push(this.getImage(d.PROJECTION_MAPBOX_IMAGE,this.option.projection.projectionMapbox,"flipY")),await Promise.all(e)}getImage(e,t,n){return new Promise(((r,o)=>{l.Z.get(t,{responseType:"blob"}).then((t=>{createImageBitmap(t.data,{imageOrientation:n,premultiplyAlpha:"none",colorSpaceConversion:"default"}).then((t=>{this._imageMap.set(e,t),r(null)}))}))}))}prepareResource(e){this._gl=e,this._updateProgram=new E(e),this._trajectoryProgram=new E(e),this._updateProgram.setShader(e,this._shaderScriptMap.get(d.UPDATE_VERTEX),this._shaderScriptMap.get(d.UPDATE_FRAGMENT),["newInfo","aliveTime"]),this._trajectoryProgram.setShader(e,this._shaderScriptMap.get(d.TRAJECTORY_VERTEX),this._shaderScriptMap.get(d.TRAJECTORY_FRAGMENT));const t=Math.ceil(Math.sqrt(this.option.constraints.maxTrajectoryNum));this._uboMapBuffer[8]=this.option.flowBoundary.uMin,this._uboMapBuffer[9]=this.option.flowBoundary.vMin,this._uboMapBuffer[10]=this.option.flowBoundary.uMax,this._uboMapBuffer[11]=this.option.flowBoundary.vMax,this._samplerMap.set(d.L_SAMPLER,u(e,e.LINEAR,e.LINEAR,e.CLAMP_TO_EDGE,e.CLAMP_TO_EDGE)),this._samplerMap.set(d.N_SAMPLER,u(e,e.NEAREST,e.NEAREST,e.CLAMP_TO_EDGE,e.CLAMP_TO_EDGE)),this._simulationVAO=e.createVertexArray(),e.bindVertexArray(this._simulationVAO);const n=new Float32Array(t*t*3).fill(0);for(let _=0;_<t*t;_++)n[3*_+0]=g(0,1),n[3*_+1]=g(0,1),n[3*_+2]=0;this._simulationBuffer=c(e,e.ARRAY_BUFFER,n,e.DYNAMIC_DRAW),e.bindBuffer(e.ARRAY_BUFFER,this._simulationBuffer),e.vertexAttribPointer(0,3,e.FLOAT,!1,12,0),e.enableVertexAttribArray(0);const r=new Float32Array(this.option.constraints.maxTrajectoryNum).fill(9*this.option.constraints.maxSegmentNum),o=c(e,e.ARRAY_BUFFER,r,e.DYNAMIC_DRAW);e.bindBuffer(e.ARRAY_BUFFER,o),e.vertexAttribPointer(1,1,e.FLOAT,!1,4,0),e.enableVertexAttribArray(1),e.bindBuffer(e.ARRAY_BUFFER,null),e.bindVertexArray(null),this._simulationVAO2=e.createVertexArray(),e.bindVertexArray(this._simulationVAO2),this._xfSimulationBuffer=c(e,e.ARRAY_BUFFER,n,e.DYNAMIC_DRAW),e.bindBuffer(e.ARRAY_BUFFER,this._xfSimulationBuffer),e.vertexAttribPointer(0,3,e.FLOAT,!1,12,0),e.enableVertexAttribArray(0);const i=c(e,e.ARRAY_BUFFER,r,e.DYNAMIC_DRAW);e.bindBuffer(e.ARRAY_BUFFER,i),e.vertexAttribPointer(1,1,e.FLOAT,!1,4,0),e.enableVertexAttribArray(1),e.bindBuffer(e.ARRAY_BUFFER,null),e.bindVertexArray(null),this._renderVAO=e.createVertexArray(),e.bindVertexArray(this._renderVAO),e.bindBuffer(e.ARRAY_BUFFER,o),e.vertexAttribPointer(0,1,e.FLOAT,!1,4,0),e.vertexAttribDivisor(0,1),e.enableVertexAttribArray(0),e.bindBuffer(e.ARRAY_BUFFER,null),e.bindVertexArray(null),this._renderVAO2=e.createVertexArray(),e.bindVertexArray(this._renderVAO2),e.bindBuffer(e.ARRAY_BUFFER,i),e.vertexAttribPointer(0,1,e.FLOAT,!1,4,0),e.vertexAttribDivisor(0,1),e.enableVertexAttribArray(0),e.bindBuffer(e.ARRAY_BUFFER,null),e.bindVertexArray(null),this._XFBO=e.createTransformFeedback(),e.bindTransformFeedback(e.TRANSFORM_FEEDBACK,this._XFBO),e.bindBuffer(e.TRANSFORM_FEEDBACK_BUFFER,this._xfSimulationBuffer),e.bindBufferRange(e.TRANSFORM_FEEDBACK_BUFFER,0,this._xfSimulationBuffer,0,t*t*12),e.bindBuffer(e.TRANSFORM_FEEDBACK_BUFFER,i),e.bindBufferRange(e.TRANSFORM_FEEDBACK_BUFFER,1,i,0,t*t*4),e.bindBuffer(e.TRANSFORM_FEEDBACK_BUFFER,null),e.bindTransformFeedback(e.TRANSFORM_FEEDBACK,null),this._XFBO2=e.createTransformFeedback(),e.bindTransformFeedback(e.TRANSFORM_FEEDBACK,this._XFBO2),e.bindBuffer(e.TRANSFORM_FEEDBACK_BUFFER,this._simulationBuffer),e.bindBufferRange(e.TRANSFORM_FEEDBACK_BUFFER,0,this._simulationBuffer,0,t*t*12),e.bindBuffer(e.TRANSFORM_FEEDBACK_BUFFER,o),e.bindBufferRange(e.TRANSFORM_FEEDBACK_BUFFER,1,o,0,t*t*4),e.bindBuffer(e.TRANSFORM_FEEDBACK_BUFFER,null),e.bindTransformFeedback(e.TRANSFORM_FEEDBACK,null),this._UBO=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,this._UBO),e.bufferData(e.ARRAY_BUFFER,48,e.DYNAMIC_DRAW),e.bindBuffer(e.ARRAY_BUFFER,null);for(let _=0;_<2;_++){const t=f(e,1,e.TEXTURE_2D,WebGL2RenderingContext.RG32F,0,0);p(e,this._imageMap.get(d.FLOW_FIELD_IMAGE+_),"Float_Point",0,this.option.textureSize.flowField[0],this.option.textureSize.flowField[1],e.TEXTURE_2D,t,WebGL2RenderingContext.RG32F,1,WebGL2RenderingContext.RG,WebGL2RenderingContext.FLOAT),this._textureMap.set(d.FLOW_FIELD_TEXTURE+_,t);const n=f(e,1,e.TEXTURE_2D,WebGL2RenderingContext.RGBA8,0,0);p(e,this._imageMap.get(d.SEEDING_IMAGE+_),"Integer",0,this.option.textureSize.seeding[0],this.option.textureSize.seeding[1],e.TEXTURE_2D,n,WebGL2RenderingContext.RGBA8,1,WebGL2RenderingContext.RGBA,WebGL2RenderingContext.UNSIGNED_BYTE),this._textureMap.set(d.SEEDING_TEXTURE+_,n)}const a=f(e,1,e.TEXTURE_2D,WebGL2RenderingContext.RG32F,0,0);p(e,this._imageMap.get(d.PROJECTION_MAPBOX_IMAGE),"Float_Point",0,this.option.textureSize.projection[0],this.option.textureSize.projection[1],e.TEXTURE_2D,a,WebGL2RenderingContext.RG32F,1,WebGL2RenderingContext.RG,WebGL2RenderingContext.FLOAT),this._textureMap.set(d.PROJECTION_MAPBOX_TEXTURE,a);const s=Math.floor(this.option.constraints.maxTextureSize/t);for(let _=0;_<this.option.constraints.maxSegmentNum;_++){const e={offsetX:_%s*t,offsetY:Math.floor(_/s)*t};this._textureOffsetArray.push(e)}n.fill(0);const l=f(e,1,e.TEXTURE_2D,WebGL2RenderingContext.RGB32F,this.option.constraints.maxTextureSize,this.option.constraints.maxTextureSize);this._textureMap.set(d.POOL_TEXTURE,l)}tickLogicCount(e){this._beginBlock=(this._beginBlock+1)%16,this.swap();const t=this.option.frequency?this.option.frequency:200;if(this._uboMapBuffer[0]=this.count/t,this._uboMapBuffer[1]=this.option.constraints.maxSegmentNum,this._uboMapBuffer[2]=10*this.option.constraints.maxSegmentNum,this._uboMapBuffer[3]=.003,this._uboMapBuffer[4]=.001,this._uboMapBuffer[5]=2,this._uboMapBuffer[6]=0,this.count===t&&this.flag){this.flag=!1,this.imagePre=this.imageNext,this.imageNext=(this.imageNext+1)%this.option.flowFields.length;const t=this,n=[];this._imageMap.set(d.FLOW_FIELD_IMAGE+"0",this._imageMap.get(d.FLOW_FIELD_IMAGE+"1")),this._imageMap.set(d.SEEDING_IMAGE+"0",this._imageMap.get(d.SEEDING_IMAGE+"1")),n.push(this.getImage(d.FLOW_FIELD_IMAGE+"1",this.option.flowFields[this.imageNext],"flipY")),n.push(this.getImage(d.SEEDING_IMAGE+"1",this.option.seeding[this.imageNext],"flipY")),Promise.all(n).then((n=>{t.flag=!0,t.count=0,t._textureMap.set(d.FLOW_FIELD_TEXTURE+"0",t._textureMap.get(d.FLOW_FIELD_TEXTURE+"1")),t._textureMap.set(d.SEEDING_TEXTURE+"0",t._textureMap.get(d.SEEDING_TEXTURE+"1"));const r=f(e,1,e.TEXTURE_2D,WebGL2RenderingContext.RG32F,0,0);p(e,t._imageMap.get(d.FLOW_FIELD_IMAGE+"1"),"Float_Point",0,t.option.textureSize.flowField[0],t.option.textureSize.flowField[1],e.TEXTURE_2D,r,WebGL2RenderingContext.RG32F,1,WebGL2RenderingContext.RG,WebGL2RenderingContext.FLOAT),t._textureMap.set(d.FLOW_FIELD_TEXTURE+"1",r);const o=f(e,1,e.TEXTURE_2D,WebGL2RenderingContext.RGBA8,0,0);p(e,t._imageMap.get(d.SEEDING_IMAGE+"1"),"Integer",0,t.option.textureSize.seeding[0],t.option.textureSize.seeding[1],e.TEXTURE_2D,o,WebGL2RenderingContext.RGBA8,1,WebGL2RenderingContext.RGBA,WebGL2RenderingContext.UNSIGNED_BYTE),t._textureMap.set(d.SEEDING_TEXTURE+"1",o)}))}}swap(){this._beginBlock%2==0?(this._sVAO=this._simulationVAO,this._rVAO=this._renderVAO,this._xfBO=this._XFBO,this._unPackBuffer=this._simulationBuffer):(this._sVAO=this._simulationVAO2,this._rVAO=this._renderVAO2,this._xfBO=this._XFBO2,this._unPackBuffer=this._xfSimulationBuffer)}bindUBO(e,t){e.bindBuffer(e.UNIFORM_BUFFER,this._UBO),e.bufferSubData(e.UNIFORM_BUFFER,0,this._uboMapBuffer),e.bindBufferRange(e.UNIFORM_BUFFER,t,this._UBO,0,4*this._uboMapBuffer.length)}tickRender(e,t){const n=Math.ceil(Math.sqrt(this.option.constraints.maxTrajectoryNum));this.bindUBO(e,0),e.bindVertexArray(this._sVAO),e.bindTransformFeedback(e.TRANSFORM_FEEDBACK,this._xfBO),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,this._textureMap.get(d.FLOW_FIELD_TEXTURE+0)),e.bindSampler(0,this._samplerMap.get(d.L_SAMPLER)),e.activeTexture(e.TEXTURE1),e.bindTexture(e.TEXTURE_2D,this._textureMap.get(d.FLOW_FIELD_TEXTURE+1)),e.bindSampler(1,this._samplerMap.get(d.L_SAMPLER)),e.activeTexture(e.TEXTURE2),e.bindTexture(e.TEXTURE_2D,this._textureMap.get(d.SEEDING_TEXTURE+0)),e.bindSampler(2,this._samplerMap.get(d.N_SAMPLER)),e.activeTexture(e.TEXTURE3),e.bindTexture(e.TEXTURE_2D,this._textureMap.get(d.SEEDING_TEXTURE+1)),e.bindSampler(3,this._samplerMap.get(d.N_SAMPLER)),this._updateProgram.useProgram(e),this._updateProgram.setVec1i(e,"flowField",[0,1]),this._updateProgram.setVec1i(e,"mask",[2,3]),this._updateProgram.setFloat(e,"randomSeed",Math.random()),this._updateProgram.setUniformBlock(e,"FlowFieldUniforms",0),e.enable(e.RASTERIZER_DISCARD),e.beginTransformFeedback(e.POINTS);const r=this.option.lineNumber?this.option.lineNumber:1e4;e.drawArrays(e.POINTS,0,r),e.endTransformFeedback(),e.disable(e.RASTERIZER_DISCARD),e.bindVertexArray(null),e.bindTransformFeedback(e.TRANSFORM_FEEDBACK,null),e.bindBuffer(e.PIXEL_UNPACK_BUFFER,this._unPackBuffer),m(e,0,n,n,e.TEXTURE_2D,this._textureMap.get(d.POOL_TEXTURE),this._textureOffsetArray[this._beginBlock].offsetX,this._textureOffsetArray[this._beginBlock].offsetY,WebGL2RenderingContext.RGB,WebGL2RenderingContext.FLOAT),e.bindBuffer(e.PIXEL_UNPACK_BUFFER,null),this._segmentPrepare>0?this._segmentPrepare--:(this.flag&&this.count++,e.bindVertexArray(this._rVAO),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,this._textureMap.get(d.POOL_TEXTURE)),e.bindSampler(0,this._samplerMap.get(d.N_SAMPLER)),e.activeTexture(e.TEXTURE1),e.bindTexture(e.TEXTURE_2D,this._textureMap.get(d.PROJECTION_MAPBOX_TEXTURE)),e.bindSampler(1,this._samplerMap.get(d.L_SAMPLER)),e.disable(e.DEPTH_TEST),e.enable(e.BLEND),e.blendColor(0,0,0,0),e.blendEquation(e.FUNC_ADD),e.blendFuncSeparate(e.ONE,e.ONE_MINUS_SRC_ALPHA,e.ONE,e.ONE_MINUS_SRC_ALPHA),this._trajectoryProgram.useProgram(e),this._trajectoryProgram.setInt(e,"particlePool",0),this._trajectoryProgram.setInt(e,"projectionTexture",1),this._trajectoryProgram.setInt(e,"blockNum",this.option.constraints.maxSegmentNum),this._trajectoryProgram.setInt(e,"beginBlock",this._beginBlock),this._trajectoryProgram.setInt(e,"blockSize",n),this._trajectoryProgram.setFloat(e,"currentSegmentNum",8),this._trajectoryProgram.setFloat(e,"fillWidth",1),this._trajectoryProgram.setFloat(e,"aaWidth",2),this._trajectoryProgram.setFloat2(e,"viewport",e.canvas.width,e.canvas.height),this._trajectoryProgram.setMat4(e,"u_matrix",t),this._trajectoryProgram.setUniformBlock(e,"FlowFieldUniforms",0),e.drawArraysInstanced(e.TRIANGLE_STRIP,0,30,r),e.disable(e.BLEND),e.bindVertexArray(null),e.bindTexture(e.TEXTURE_2D,null))}async generateCustomLayer(e){const t=this;let n;await this.prepareAsyncImage();const r={id:e,type:"custom",onAdd(e,r){const o=r.getSupportedExtensions();for(const t of o)r.getExtension(t);n=e,t.prepareResource.call(t,r)},render(e,r){t.tickLogicCount(e),t.tickRender(e,r),n.triggerRepaint()}};return r}changeState(e){if(!this._gl||e>=this.option.flowFields.length)return;const t=this._gl;this.flag=!1,this.imagePre=e,this.imageNext=(e+1)%this.option.flowFields.length;const n=[];n.push(this.getImage(d.FLOW_FIELD_IMAGE+"0",this.option.flowFields[this.imagePre],"flipY")),n.push(this.getImage(d.SEEDING_IMAGE+"0",this.option.seeding[this.imagePre],"flipY")),n.push(this.getImage(d.FLOW_FIELD_IMAGE+"1",this.option.flowFields[this.imageNext],"flipY")),n.push(this.getImage(d.SEEDING_IMAGE+"1",this.option.seeding[this.imageNext],"flipY")),Promise.all(n).then((e=>{this.flag=!0,this.count=0;const n=f(t,1,t.TEXTURE_2D,WebGL2RenderingContext.RG32F,0,0);p(t,this._imageMap.get(d.FLOW_FIELD_IMAGE+"0"),"Float_Point",0,this.option.textureSize.flowField[0],this.option.textureSize.flowField[1],t.TEXTURE_2D,n,WebGL2RenderingContext.RG32F,1,WebGL2RenderingContext.RG,WebGL2RenderingContext.FLOAT),this._textureMap.set(d.FLOW_FIELD_TEXTURE+"0",n);const r=f(t,1,t.TEXTURE_2D,WebGL2RenderingContext.RG32F,0,0);p(t,this._imageMap.get(d.FLOW_FIELD_IMAGE+"1"),"Float_Point",0,this.option.textureSize.flowField[0],this.option.textureSize.flowField[1],t.TEXTURE_2D,r,WebGL2RenderingContext.RG32F,1,WebGL2RenderingContext.RG,WebGL2RenderingContext.FLOAT),this._textureMap.set(d.FLOW_FIELD_TEXTURE+"0",r);const o=f(t,1,t.TEXTURE_2D,WebGL2RenderingContext.RGBA8,0,0);p(t,this._imageMap.get(d.SEEDING_IMAGE+"0"),"Integer",0,this.option.textureSize.seeding[0],this.option.textureSize.seeding[1],t.TEXTURE_2D,o,WebGL2RenderingContext.RGBA8,1,WebGL2RenderingContext.RGBA,WebGL2RenderingContext.UNSIGNED_BYTE),this._textureMap.set(d.SEEDING_TEXTURE+"0",o);const i=f(t,1,t.TEXTURE_2D,WebGL2RenderingContext.RGBA8,0,0);p(t,this._imageMap.get(d.SEEDING_IMAGE+"1"),"Integer",0,this.option.textureSize.seeding[0],this.option.textureSize.seeding[1],t.TEXTURE_2D,i,WebGL2RenderingContext.RGBA8,1,WebGL2RenderingContext.RGBA,WebGL2RenderingContext.UNSIGNED_BYTE),this._textureMap.set(d.SEEDING_TEXTURE+"1",i)}))}}const u=(e,t,n,r,o,i)=>{const a=e.createSampler();return e.samplerParameteri(a,e.TEXTURE_MAG_FILTER,t),e.samplerParameteri(a,e.TEXTURE_MIN_FILTER,n),e.samplerParameteri(a,e.TEXTURE_WRAP_S,r),e.samplerParameteri(a,e.TEXTURE_WRAP_T,o),i&&e.samplerParameteri(a,e.TEXTURE_WRAP_R,i),a},f=(e,t,n,r,o,i)=>{const a=e.createTexture();return 0!==o&&0!==i&&(e.bindTexture(n,a),e.texStorage2D(n,t,r,o,i),e.bindTexture(n,null)),a},c=(e,t,n,r)=>{const o=e.createBuffer();return e.bindBuffer(t,o),e.bufferData(t,n,r),o},p=(e,t,n,r,o,i,a,s,l,_,u,f)=>{if(e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL,0),e.bindTexture(a,s),e.texStorage2D(a,_,l,o,i),e.bindTexture(a,null),"Float_Point"===n){const n=new Uint8Array(t.width*t.height*4),l=e.createTexture();e.bindTexture(e.TEXTURE_2D,l),e.texImage2D(e.TEXTURE_2D,0,e.RGBA8,t.width,t.height,0,e.RGBA,e.UNSIGNED_BYTE,t),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,e.LINEAR),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,e.LINEAR);const c=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,c),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,l,0),e.readPixels(0,0,t.width,t.height,e.RGBA,e.UNSIGNED_BYTE,n),e.bindFramebuffer(e.FRAMEBUFFER,null),e.bindTexture(a,s),e.texSubImage2D(a,r,0,0,o,i,u,f,new Float32Array(n.buffer)),_>1&&e.generateMipmap(a),e.bindTexture(a,null)}else"Integer"===n&&(e.bindTexture(a,s),e.texSubImage2D(a,r,0,0,o,i,u,f,t),_>1&&e.generateMipmap(a),e.bindTexture(a,null))},m=(e,t,n,r,o,i,a,s,l,_)=>{e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!1),e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL,0),e.bindTexture(o,i),e.texSubImage2D(o,t,a,s,n,r,l,_,0),e.bindTexture(o,null)},d={UPDATE_VERTEX:"update_vertex",UPDATE_FRAGMENT:"update_fragment",TRAJECTORY_VERTEX:"trajectory_vertex",TRAJECTORY_FRAGMENT:"trajectory_fragment",POINT_VERTEX:"point_vertex",POINT_FRAGMENT:"point_fragment",POOL_VERTEX:"pool_vertex",POOL_FRAGMENT:"pool_fragment",L_SAMPLER:"l_sampler",N_SAMPLER:"n_sampler",FLOW_FIELD_IMAGE:"flow_field_image",SEEDING_IMAGE:"seeding_image",PROJECTION_MAPBOX_IMAGE:"projection_mapbox_image",PROJECTION_CESIUM_IMAGE:"projection_cesium_image",PROJECTION_OL_IMAGE:"projection_ol_image",FLOW_FIELD_TEXTURE:"flow_field_texture",SEEDING_TEXTURE:"seeding_texture",PROJECTION_MAPBOX_TEXTURE:"projection_mapbox_texture",PROJECTION_CESIUM_TEXTURE:"projection_cesium_texture",PROJECTION_OL_TEXTURE:"projection_ol_texture",POOL_TEXTURE:"pool_texture"};class E{constructor(e){this.program=e.createProgram()}setShader(e,t,n,r){if(this.program){const o=e.createShader(e.VERTEX_SHADER),i=e.createShader(e.FRAGMENT_SHADER);e.shaderSource(o,t),e.shaderSource(i,n),e.compileShader(o),e.compileShader(i),e.getShaderParameter(o,e.COMPILE_STATUS)||console.error("shader compiler error:\n"+e.getShaderInfoLog(o)),e.attachShader(this.program,o),e.attachShader(this.program,i),r&&e.transformFeedbackVaryings(this.program,r,e.SEPARATE_ATTRIBS),e.linkProgram(this.program)}}useProgram(e){e.useProgram(this.program)}setFloat(e,t,n){const r=e.getUniformLocation(this.program,t);e.uniform1f(r,n)}setInt(e,t,n){const r=e.getUniformLocation(this.program,t);e.uniform1i(r,n)}setVec1i(e,t,n){const r=e.getUniformLocation(this.program,t);e.uniform1iv(r,n)}setFloat2(e,t,n,r){const o=e.getUniformLocation(this.program,t);e.uniform2f(o,n,r)}setFloat3(e,t,n,r,o){const i=e.getUniformLocation(this.program,t);e.uniform3f(i,n,r,o)}setFloat4(e,t,n,r,o,i){const a=e.getUniformLocation(this.program,t);e.uniform4f(a,n,r,o,i)}setVec4(e,t,n){const r=e.getUniformLocation(this.program,t);e.uniform4fv(r,n)}setMat4(e,t,n){const r=e.getUniformLocation(this.program,t);e.uniformMatrix4fv(r,!1,n)}setUniformBlock(e,t,n){const r=e.getUniformBlockIndex(this.program,t);e.uniformBlockBinding(this.program,r,n)}}const g=(e,t)=>(t||(t=e,e=0),Math.random()*(t-e)+e);var h=n(7709),x=n.n(h),R=(0,r.aZ)({setup(){const e=(0,a.iH)();let t;const n=new _({seeding:["/flow/texture/mask_100.png","/flow/texture/mask_101.png","/flow/texture/mask_102.png","/flow/texture/mask_103.png","/flow/texture/mask_104.png","/flow/texture/mask_105.png","/flow/texture/mask_106.png","/flow/texture/mask_107.png","/flow/texture/mask_108.png","/flow/texture/mask_109.png","/flow/texture/mask_110.png","/flow/texture/mask_111.png","/flow/texture/mask_112.png","/flow/texture/mask_113.png","/flow/texture/mask_114.png","/flow/texture/mask_115.png","/flow/texture/mask_116.png","/flow/texture/mask_117.png","/flow/texture/mask_118.png","/flow/texture/mask_119.png","/flow/texture/mask_120.png","/flow/texture/mask_121.png","/flow/texture/mask_122.png","/flow/texture/mask_123.png","/flow/texture/mask_124.png","/flow/texture/mask_125.png","/flow/texture/mask_126.png"],constraints:{maxDropRate:.1,maxDropRateBump:.2,maxSegmentNum:16,maxTrajectoryNum:262144,maxTextureSize:4096},extent:[.8334519409367115,.4087464036632672,.8388303296774701,.40586521884815613],flowBoundary:{uMax:2.3461,uMin:-2.1176,vMax:2.0175,vMin:-1.8959},flowFields:["/flow/texture/uv_100.png","/flow/texture/uv_101.png","/flow/texture/uv_102.png","/flow/texture/uv_103.png","/flow/texture/uv_104.png","/flow/texture/uv_105.png","/flow/texture/uv_106.png","/flow/texture/uv_107.png","/flow/texture/uv_108.png","/flow/texture/uv_109.png","/flow/texture/uv_110.png","/flow/texture/uv_111.png","/flow/texture/uv_112.png","/flow/texture/uv_113.png","/flow/texture/uv_114.png","/flow/texture/uv_115.png","/flow/texture/uv_116.png","/flow/texture/uv_117.png","/flow/texture/uv_118.png","/flow/texture/uv_119.png","/flow/texture/uv_120.png","/flow/texture/uv_121.png","/flow/texture/uv_122.png","/flow/texture/uv_123.png","/flow/texture/uv_124.png","/flow/texture/uv_125.png","/flow/texture/uv_126.png"],projection:{projectionMapbox:"/flow/texture/projection_mapbox.png",projectionCesium:"/flow/texture/projection_cesium.png",projectionOl:"/flow/texture/projection_ol.png"},textureSize:{seeding:[1024,558],flowField:[1024,558],projection:[1024,2048]}}),o=()=>{n.changeState(22)},i=n=>{const r={container:e.value,style:"mapbox://styles/johnnyt/clblx2t3v000a14proaq4e9qv",center:[121.024075,31.765318],zoom:8.8,useWebGL2:!0,antialias:!0,accessToken:"pk.eyJ1Ijoiam9obm55dCIsImEiOiJja2xxNXplNjYwNnhzMm5uYTJtdHVlbTByIn0.f1GfZbFLWjiEayI6hb_Qvg"};t=new(x().Map)(r),t.on("load",(()=>{t.addLayer(n)}))};return(0,r.bv)((async()=>{const e=await n.generateCustomLayer("flow");i(e)})),{container:e,clickHandle:o}}}),T=n(89);const A=(0,T.Z)(R,[["render",i]]);var b=A},7327:function(e,t,n){function r(e){return r="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},r(e)}function o(e,t){if("object"!==r(e)||null===e)return e;var n=e[Symbol.toPrimitive];if(void 0!==n){var o=n.call(e,t||"default");if("object"!==r(o))return o;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===t?String:Number)(e)}function i(e){var t=o(e,"string");return"symbol"===r(t)?t:String(t)}function a(e,t,n){return t=i(t),t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}n.d(t,{Z:function(){return a}})}}]);
//# sourceMappingURL=172.244b453d.js.map